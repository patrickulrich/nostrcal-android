NIP-52
======

Calendar Events
---------------

`draft` `optional`

This specification defines calendar events representing an occurrence at a specific moment or between moments. These calendar events are _addressable_ and deletable per [NIP-09](09.md).

Unlike the term `calendar event` specific to this NIP, the term `event` is used broadly in all the NIPs to describe any Nostr event. The distinction is being made here to discern between the two terms.

## Calendar Events

There are two types of calendar events represented by different kinds: _date-based_ and _time-based_ calendar events.

These tags are common to both types of calendar events:

* `d` (required) a short unique string identifier. Generated by the client creating the calendar event.
* `title` (required) title of the calendar event
* `summary` (optional) brief description of the calendar event
* `image` (optional) url of an image to use for the event
* `location` (optional, repeated) location of the calendar event. e.g. address, GPS coordinates, meeting room name, link to video call
* `g` (optional) [geohash](https://en.wikipedia.org/wiki/Geohash) to associate calendar event with a searchable physical location
* `p` (optional, repeated) 32-bytes hex pubkey of a participant, optional recommended relay URL, and participant's role in the meeting
* `t` (optional, repeated) hashtag to categorize calendar event
* `r` (optional, repeated) references / links to web pages, documents, video calls, recorded videos, etc.

The following tags are deprecated:

* `name` name of the calendar event. Use only if `title` is not available.

Calendar events are _not_ required to be part of a [calendar](#calendar).

### Date-Based Calendar Event

This kind of calendar event starts on a date and ends before a different date in the future. Its use is appropriate for all-day or multi-day events where time and time zone hold no significance. e.g., anniversary, public holidays, vacation days.

It's an _addressable event_ of `kind:31922`.

The `.content` of these events SHOULD be a description of the calendar event.

Aside from the common tags, this also takes the following tags:

* `start` (required) inclusive start date in ISO 8601 format (YYYY-MM-DD). Must be less than `end`, if it exists.
* `end` (optional) exclusive end date in ISO 8601 format (YYYY-MM-DD). If omitted, the calendar event ends on the same date as `start`.

Example:

```yaml
{
  "id": <32-bytes lowercase hex-encoded SHA-256 of the the serialized event data>,
  "pubkey": <32-bytes lowercase hex-encoded public key of the event creator>,
  "created_at": <unix timestamp in seconds>,
  "kind": 31922,
  "content": "<description of calendar event>",
  "tags": [
    ["d", "<random-identifier>"],

    ["title", "<title of calendar event>"],

    // dates
    ["start", "<YYYY-MM-DD>"],
    ["end", "<YYYY-MM-DD>"],

    // location
    ["location", "<location>"],
    ["g", "<geohash>"],

    // participants
    ["p", "<32-bytes hex of a pubkey>", "<optional recommended relay URL>", "<role>"],
    ["p", "<32-bytes hex of a pubkey>", "<optional recommended relay URL>", "<role>"],
  ]
}
```

### Time-Based Calendar Event

This kind of calendar event spans between a start time and end time.

It's an _addressable event_ of `kind:31923`.

The `.content` of these events should be a description of the calendar event. It is required but can be an empty string.

Aside from the common tags, this also takes the following tags:

* `start` (required) inclusive start Unix timestamp in seconds. Must be less than `end`, if it exists.
* `end` (optional) exclusive end Unix timestamp in seconds. If omitted, the calendar event ends instantaneously.
* `start_tzid` (optional) time zone of the start timestamp, as defined by the IANA Time Zone Database. e.g., `America/Costa_Rica`
* `end_tzid` (optional) time zone of the end timestamp, as defined by the IANA Time Zone Database. e.g., `America/Costa_Rica`. If omitted and `start_tzid` is provided, the time zone of the end timestamp is the same as the start timestamp.

```yaml
{
  "id": <32-bytes lowercase hex-encoded SHA-256 of the the serialized event data>,
  "pubkey": <32-bytes lowercase hex-encoded public key of the event creator>,
  "created_at": <unix timestamp in seconds>,
  "kind": 31923,
  "content": "<description of calendar event>",
  "tags": [
    ["d", "<random-identifier>"],

    ["title", "<title of calendar event>"],
    ["summary", "<brief description of the calendar event>"],
    ["image", "<string with image URI>"],

    // timestamps
    ["start", "<unix timestamp in seconds>"],
    ["end", "<unix timestamp in seconds>"],

    ["start_tzid", "<IANA Time Zone Database identifier>"],
    ["end_tzid", "<IANA Time Zone Database identifier>"],

    // location
    ["location", "<location>"],
    ["g", "<geohash>"],

    // participants
    ["p", "<32-bytes hex of a pubkey>", "<optional recommended relay URL>", "<role>"],
    ["p", "<32-bytes hex of a pubkey>", "<optional recommended relay URL>", "<role>"],
  ]
}
```

## Calendar

A calendar is a collection of calendar events, represented as a custom _addressable list_ event using kind `31924`. A user can have multiple calendars. One may create a calendar to segment calendar events for specific purposes. e.g., personal, work, travel, meetups, and conferences.

The `.content` of these events should be a detailed description of the calendar. It is required but can be an empty string.

* `d` (required) universally unique identifier. Generated by the client creating the calendar.
* `title` (required) calendar title
* `a` (repeated) reference tag to kind `31922`, `31923` or `31927` calendar event being responded to

```yaml
{
  "id": <32-bytes lowercase hex-encoded SHA-256 of the the serialized event data>,
  "pubkey": <32-bytes lowercase hex-encoded public key of the event creator>,
  "created_at": <unix timestamp in seconds>,
  "kind": 31924,
  "content": "<description of calendar>",
  "tags": [
    ["d", "<random-identifier>"],
    ["title", "<calendar title>"],
    ["a", "<31922>:<calendar event author pubkey>:<d-identifier of calendar event>", "<optional relay url>"],
    ["a", "<31923>:<calendar event author pubkey>:<d-identifier of calendar event>", "<optional relay url>"],
    ["a", "<31927>:<calendar event author pubkey>:<d-identifier of calendar event>", "<optional relay url>"]
  ]
}
```

## Calendar Event RSVP

A calendar event RSVP is a response to a calendar event to indicate a user's attendance intention.

If a calendar event tags a pubkey, that can be interpreted as the calendar event creator inviting that user to attend. Clients MAY choose to prompt the user to RSVP for the calendar event.

Any user may RSVP, even if they were not tagged on the calendar event. Clients MAY choose to prompt the calendar event creator to invite the user who RSVP'd. Clients also MAY choose to ignore these RSVPs.

This NIP is intentionally not defining who is authorized to attend a calendar event if the user who RSVP'd has not been tagged. It is up to the calendar event creator to determine the semantics.

This NIP is also intentionally not defining what happens if a calendar event changes after an RSVP is submitted.

The RSVP MUST have an `a` tag of the event coordinates to the calendar event, and optionally an `e` tag of the id of the specific calendar event revision. If an `e` tag is present, clients SHOULD interpret it as an indication that the RSVP is a response to that revision of the calendar event, and MAY interpret it to not necessarily apply to other revisions of the calendar event.

The RSVP MAY tag the author of the calendar event it is in response to using a `p` tag so that clients can easily query all RSVPs that pertain to the author.

The RSVP is an _addressable event_ of `kind:31925`.

The `.content` of these events is optional and should be a free-form note that adds more context to this calendar event response.

The list of tags is as follows:

* `a` (required) coordinates to a kind `31922` or `31923` calendar event being responded to.
* `e` (optional) event id of a kind `31922` or `31923` calendar event being responded to.
* `d` (required) universally unique identifier. Generated by the client creating the calendar event RSVP.
* `status` (required) `accepted`, `declined`, or `tentative`. Determines attendance status to the referenced calendar event.
* `fb` (optional) `free` or `busy`. Determines if the user would be free or busy for the duration of the calendar event. This tag must be omitted or ignored if the `status` label is set to `declined`.
* `p` (optional) pubkey of the author of the calendar event being responded to.

```yaml
{
  "id": <32-bytes lowercase hex-encoded SHA-256 of the the serialized event data>,
  "pubkey": <32-bytes lowercase hex-encoded public key of the event creator>,
  "created_at": <unix timestamp in seconds>,
  "kind": 31925,
  "content": "<note>",
  "tags": [
    ["e", "<kind 31922 or 31923 event id", "<optional recommended relay URL>"]
    ["a", "<31922 or 31923>:<calendar event author pubkey>:<d-identifier of calendar event>", "<optional recommended relay URL>"],
    ["d", "<random-identifier>"],
    ["status", "<accepted/declined/tentative>"],
    ["fb", "<free/busy>"],
    ["p", "<hex pubkey of kind 31922 or 31923 event>", "<optional recommended relay URL>"]
  ]
}
```

## Calendar Availability

A Calendar Availability event advertises a user's recurring open hours and booking parameters. It's an _addressable list_ event of `kind: 31926`, typically linked to one of the user's Calendars (`kind: 31924`). Clients can combine this template with user's other calendar events to compute real-time free slots.

The `.content` field is optional.

* `a` (required) Links this template to a calendar (e.g. `"a","31924:<owner-pubkey>:<calendar-d>"`) 
* `d` (required) Deterministic identifier (16-char hex).
* `title` (required) Label shown to bookers (e.g. `"Office Hours"`).
* `sch` (required, repeatable) weekly open block — `["sch","<DOW>","<START>","<END>"]`; ISO-8601 day codes (MO, TU, WE, TH, FR, SA, SU) with 24-hour times (HH:MM), inclusive start, exclusive end.
* `tzid` (optional) IANA time zone for all `sch` blocks (default: `UTC`).
* `duration` (optional) ISO‑8601 duration for each booking (e.g. `PT1H`). Default: `PT30M`.
* `interval` (optional) ISO‑8601 gap between starts of consecutive slots (e.g. `PT15M`). Default: same as `duration`.
* `buffer_before`, `buffer_after` (optional) ISO‑8601 duration to reserve time before/after each slot. Default: `PT0S`.
* `min_notice` (optional) ISO‑8601 period that must elapse between "now" and slot start (e.g. `P3D`). Default: `PT0S`.
* `max_advance` (optional) ISO‑8601 period beyond which slots may not be booked. Default: `PT0S`.
* `max_advance_business` (optional) `"true"` or `"false"`. If `"true"`, count business days. Default: `"false"`.
* `amount` (optional) Integer satoshis required to confirm a slot (omit or `"0"` for free).

If multiple `sch` blocks overlap, they should be merged into a single continuous availability window. For example:
- `["sch","MO","13:00","15:00"]`
- `["sch","MO","14:00","17:00"]`

Results in availability from 13:00-17:00 on Monday.

```yaml
{
  "kind": 31926,
  "content": "Weekly office hours template",
  "tags": [
    ["a","31924:npub1abcd…:work-cal"],
    ["d","avail-main"],
    ["title","Office Hours"],
    ["sch","MO","13:00","17:00"],
    ["sch","WE","13:00","17:00"],
    ["tzid","America/New_York"],
    ["duration","PT1H"],
    ["interval","PT30M"],
    ["buffer_before","PT5M"],
    ["buffer_after","PT10M"],
    ["min_notice","P3D"],
    ["max_advance","P30D"],
    ["max_advance_business","true"],
    ["amount","20"]
  ]
}
```

## Calendar Availability Block

A Calendar Availability Block event publishes specific time ranges when a user is busy. It's an _addressable event_ of `kind: 31927` that enables booking systems to determine availability without exposing event details or social connections.

Unlike RSVPs (kind 31925), these blocks do not reference specific calendar events, preserving privacy while enabling scheduling functionality.

The `.content` field is optional.

* `d` (required) Unique identifier. Generated by the client.
* `start` (required) Inclusive start Unix timestamp in seconds.
* `end` (required) Exclusive end Unix timestamp in seconds. Must be greater than `start`.

```yaml
{
  "id": <32-bytes lowercase hex-encoded SHA-256 of the the serialized event data>,
  "pubkey": <32-bytes lowercase hex-encoded public key of the event creator>,
  "created_at": <unix timestamp in seconds>,
  "kind": 31927,
  "content": "",
  "tags": [
    ["d", "<unique-identifier>"],
    ["start", "1703088000"],
    ["end", "1703091600"]
  ]
}
```

### Usage with Private Calendar Events

When a user creates another private event or RSVPs to a private calendar event with `status: accepted` and `fb: busy`, clients SHOULD automatically create or update a corresponding public kind 31927 event for that time range. This allows booking systems to see busy times without accessing private event details.

Clients SHOULD merge overlapping busy blocks to minimize metadata leakage about meeting patterns.

## Private Calendar Events

This section defines an encrypted calendar event scheme using [NIP-44](44.md) encryption and [NIP-59](59.md) seals and gift wraps.

### Calendar Event Kinds in Private Context

Kinds `31922`, `31923`, `31924`, `31925`, and `31926` are used as defined in the public section, but MUST never be signed when used privately. If signed, the calendar event might leak to relays and become **fully public**.

```jsonc
{
  "id": "<usual hash>",
  "pubkey": "<event-creator-pubkey>",
  "created_at": "<current-time>",
  "kind": 31923,
  "tags": [
    ["d", "quarterly-planning-q1"],
    ["title", "Q1 Planning Meeting"],
    ["start", "1703088000"],
    ["end", "1703095200"],
    ["location", "Conference Room A"],
    ["p", "<participant-1-pubkey>", "<relay-url>", "required"],
    ["p", "<participant-2-pubkey>", "<relay-url>", "optional"],
    // other tags...
  ],
  "content": "Quarterly planning meeting agenda...",
}
```

Fields `id` and `created_at` are required.

### Calendar Privacy

The set of `pubkey` + `p` tags defines a calendar event's participant list. If participants are added or removed, clients SHOULD send event updates (maintaining the same `d` tag) to reflect the new participant list.

Updates to private calendar events are handled by creating a new rumor with the same `d` tag and gift wrapping it to all current participants.

Event deletion uses [NIP-09](09.md) deletion requests, gift wrapped to all participants.

### Encrypting

Following [NIP-59](59.md), the **unsigned** calendar event must be sealed (`kind:13`) and then gift-wrapped (`kind:1059`) to each participant individually.

```js
{
  "id": "<usual hash>",
  "pubkey": randomPublicKey,
  "created_at": randomTimeUpTo2DaysInThePast(),
  "kind": 1059, // gift wrap
  "tags": [
    ["p", receiverPublicKey, "<relay-url>"] // receiver
  ],
  "content": nip44Encrypt(
    {
      "id": "<usual hash>",
      "pubkey": senderPublicKey,
      "created_at": randomTimeUpTo2DaysInThePast(),
      "kind": 13, // seal
      "tags": [], // no tags
      "content": nip44Encrypt(unsignedCalendarEvent, senderPrivateKey, receiverPublicKey),
      "sig": "<signed by senderPrivateKey>"
    },
    randomPrivateKey, receiverPublicKey
  ),
  "sig": "<signed by randomPrivateKey>"
}
```

The encryption algorithm MUST use the latest version of [NIP-44](44.md).

Clients MUST verify that the pubkey of the `kind:13` seal is the same pubkey on the inner calendar event.

Clients SHOULD randomize `created_at` in up to two days in the past in both the seal and the gift wrap to make sure grouping by `created_at` doesn't reveal any metadata.

### Publishing

Kind `10050` indicates the user's preferred relays to receive calendar gift wraps. The event MUST include a list of `relay` tags with relay URIs.

```jsonc
{
  "kind": 10050,
  "tags": [
    ["relay", "wss://auth.nostr1.com"],
    ["relay", "wss://inbox.nostr.wine"],
  ],
  "content": "",
  // other fields...
}
```

Clients SHOULD publish calendar gift wraps to the participant's `10050`-listed relays. If that is not found that indicates the user is not ready to publish Calendar events under this NIP and clients shouldn't try.

### Relays

It's advisable that relays do not serve `kind:1059` to clients other than the ones tagged in them.

It's advisable that users choose relays that conform to these practices.

Clients SHOULD guide users to keep `kind:10050` lists small (1-3 relays) and SHOULD spread it to as many relays as viable.

### Benefits & Limitations

This approach offers the following privacy and security features:

1. **No Metadata Leak**: Event details, participant lists, timing, and other tags are all hidden from public view
2. **No Public Calendar Identifiers**: Private calendars have no public presence
3. **Full Event Control**: Only participants can see and interact with the event
4. **Fully Recoverable**: Events can be recovered by any client with the user's private key
5. **Uses Public Relays**: Calendar events can flow through public relays without loss of privacy
6. **Optional Forward Secrecy**: Clients can implement disappearing events by setting an expiration tag in gift wraps, or by not creating a gift wrap for the sender's own key (preventing recovery of sent events)

The main limitation is having to send a separate encrypted event to each participant. Calendar events with more than 100 participants should consider alternative approaches.

### Implementation

Clients implementing private calendar events should:
- Query their regular relays for public calendar events
- Query their `kind:10050` list for gift wrapped events
- Send gift wrapped events only to participants' `kind:10050` relays

When sending a calendar event to participants, clients must connect to each participant's `kind:10050` relays and send the gift wrap there. Clients should send a copy of their outgoing calendar events to their own `kind:10050` relay set.

For RSVPs, clients must gift wrap the response to all participants found in the original event's `p` tags, ensuring all participants can track attendance.

### Example Flow

#### 1. Alice creates a private meeting

Alice wants to schedule a meeting with Bob and Carol.

**Create the unsigned calendar event:**
```json
{
  "kind": 31923,
  "content": "Team sync to discuss Q1 goals",
  "created_at": 1703015180,
  "pubkey": "alice-pubkey",
  "tags": [
    ["d", "team-sync-jan-2025"],
    ["title", "Team Sync"],
    ["start", "1703088000"],
    ["end", "1703091600"],
    ["location", "https://meet.example.com/team"],
    ["p", "bob-pubkey", "", "required"],
    ["p", "carol-pubkey", "", "required"]
  ]
}
```

**Alice creates gift wraps for Bob and Carol** (following the encryption process above) and sends to their respective `kind:10050` relays.

#### 2. Bob RSVPs

Bob decrypts the gift wrap, sees the meeting, and creates an RSVP:

**Create the unsigned RSVP:**
```json
{
  "kind": 31925,
  "content": "I'll be there!",
  "created_at": 1703020000,
  "pubkey": "bob-pubkey",
  "tags": [
    ["a", "31923:alice-pubkey:team-sync-jan-2025"],
    ["d", "bob-rsvp-team-sync"],
    ["status", "accepted"],
    ["fb", "busy"]
  ]
}
```

**Bob creates gift wraps for Alice AND Carol** so everyone can see his response.

#### 3. Meeting update

If Alice needs to change the time, she creates a new rumor with the **same `d` tag** but updated start/end times, then gift wraps to all participants.

## Intentionally Unsupported Scenarios

### Recurring Calendar Events

Recurring calendar events come with a lot of complexity, making it difficult for software and humans to deal with. This complexity includes time zone differences between invitees, daylight savings, leap years, multiple calendar systems, one-off changes in schedule or other metadata, etc.

This NIP intentionally omits support for recurring calendar events and pushes that complexity up to clients to manually implement if they desire. i.e., individual calendar events with duplicated metadata represent recurring calendar events.
